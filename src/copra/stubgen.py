"""Generate Python type stubs for cocotb testbenches."""

import argparse
import re
import sys
from pathlib import Path
from typing import Dict, Type, Any, Optional, Union, List, Set, Tuple

import cocotb
from cocotb.handle import (
    HierarchyObject,
    ModifiableObject,
    NonHierarchyObject,
    HierarchyArrayObject,
    SimHandle,
    SimHandleBase,
    IntegerObject,
    RealObject,
    StringObject,
    EnumObject,
)
from cocotb.types import Logic, LogicArray


def discover_hierarchy(dut: HierarchyObject) -> Dict[str, type]:
    """Discover the hierarchy of objects in the DUT.
    
    Args:
        dut: The root DUT object.
        
    Returns:
        A dictionary mapping hierarchical paths to their corresponding Python types.
    """
    hierarchy: Dict[str, type] = {}
    
    def _discover(obj: object, path: str) -> None:
        """Recursively discover the DUT hierarchy.

        Args:
            obj: The current object to discover.
            path: The current path in the hierarchy.
        """
        if not hasattr(obj, '_name'):
            return

        full_path = f"{path}.{obj._name}" if path else obj._name
        
        # For mock handles, use the _type attribute if it exists
        if hasattr(obj, '_type') and obj._type is not None:
            hierarchy[full_path] = obj._type
        else:
            hierarchy[full_path] = type(obj)

        # Handle both real cocotb handles and mock test handles
        sub_handles = {}
        
        # For mock handles used in tests
        if hasattr(obj, '_sub_handles') and isinstance(obj._sub_handles, dict):
            sub_handles = obj._sub_handles
        # For real cocotb handles
        elif hasattr(obj, '_sub_handles') and hasattr(obj, '_sub_handles_iter'):
            sub_handles = {h._name: h for h in obj._sub_handles_iter()}
        # For HierarchyArrayObject
        elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):
            try:
                for i, child in enumerate(obj):
                    _discover(child, f"{full_path}[{i}]")
                return
            except (TypeError, AttributeError):
                pass
        
        # Recursively discover sub-handles
        for name, child in sub_handles.items():
            _discover(child, full_path)
    
    _discover(dut, "")
    return hierarchy


def generate_stub(hierarchy: Dict[str, type]) -> str:
    """Generate a Python stub file from the discovered hierarchy.
    
    Args:
        hierarchy: Dictionary mapping paths to types.
        
    Returns:
        A string containing the generated stub file content.
    """
    lines = [
        "# This is an auto-generated stub file for cocotb testbench",
        "# Generated by copra",
        "from typing import Any, List, Optional, Union, Dict, Tuple, Set, Callable, Type, TypeVar",
        "import cocotb.handle",
        "from cocotb.handle import (",
        "    HierarchyObject,",
        "    ModifiableObject,",
        "    NonHierarchyObject,",
        "    HierarchyArrayObject,",
        "    HierarchyObjectIterator,",
        "    RealObject,",
        "    EnumObject,",
        "    IntegerObject,",
        "    StringObject,",
        "    LogicObject,",
        "    Range,",
        "    SimHandleBase,",
        ")",
        "from cocotb.types import Logic, LogicArray, BitArray, BinaryValue",
        "",
    ]
    
    # Generate class definitions for each hierarchy level
    processed: Set[str] = set()
    current_class: Optional[str] = None
    
    for path in sorted(hierarchy.keys()):
        parts = path.split('.')
        
        # Handle array indices
        if '[' in parts[-1]:
            base_name = parts[-1].split('[')[0]
            parts[-1] = base_name
            
        # Create a new class if we're at a new hierarchy level
        current = '.'.join(parts)
        if current not in processed:
            if current_class:
                lines.append('    pass')
            
            if len(parts) > 1:
                parent = '.'.join(parts[:-1])
                parent_class = parent.split('.')[-1]
                base_class = parent_class
            else:
                base_class = 'HierarchyObject'
            
            class_name = parts[-1]
            lines.append(f'class {class_name}({base_class}):')
            lines.append(f'    """Auto-generated class for {current}."""')
            current_class = class_name
            processed.add(current)
            
        # Add attributes for this level
        obj_type = hierarchy.get(path, HierarchyObject)
        if obj_type is ModifiableObject:
            lines.append(f'    {parts[-1]}: ModifiableObject[Any]')
        elif obj_type is NonHierarchyObject:
            lines.append(f'    {parts[-1]}: NonHierarchyObject[Any]')
        elif obj_type is HierarchyObject:
            lines.append(f'    {parts[-1]}: HierarchyObject')
        elif obj_type is HierarchyArrayObject:
            lines.append(f'    {parts[-1]}: HierarchyArrayObject')
            # Add array access methods
            lines.append(f'    def __getitem__(self, index: int) -> ModifiableObject[Any]: ...')
            lines.append(f'    def __len__(self) -> int: ...')
    
    if current_class:
        lines.append('    pass')
    
    return '\n'.join(lines)


def main(args: Optional[List[str]] = None) -> int:
    """Main entry point for the copra CLI.
    
    Args:
        args: Command line arguments. If None, uses sys.argv[1:].
        
    Returns:
        Exit code.
    """
    parser = argparse.ArgumentParser(description='Generate Python type stubs for cocotb testbenches.')
    parser.add_argument(
        'top_module',
        help='Top-level module name to generate stubs for',
    )
    parser.add_argument(
        '--outfile',
        default='dut.pyi',
        help='Output file path (default: dut.pyi)',
    )
    
    parsed_args = parser.parse_args(args)
    
    # This is a placeholder for the actual simulation run
    # In a real implementation, we would run the simulation in discovery mode
    print(f"Would generate stubs for {parsed_args.top_module} in {parsed_args.outfile}")
    print("Note: This is a placeholder implementation. The actual stub generation")
    print("will be implemented based on the cocotb simulation introspection.")
    
    # Example of what the implementation would look like:
    # with Simulator(parsed_args.top_module) as sim:
    #     dut = sim.start()
    #     hierarchy = discover_hierarchy(dut)
    #     stub_content = generate_stub(hierarchy)
    #     Path(parsed_args.outfile).write_text(stub_content)
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
