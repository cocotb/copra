from __future__ import annotations

import os
from dataclasses import dataclass, field
from typing import Dict, List, Set

@dataclass
class TypePatterns:
    """Patterns for type detection through cocotb handles only."""
    value_object_patterns: List[str] = field(default_factory=lambda: [
        'LogicObject', 'LogicArrayObject', 'IntegerObject', 
        'RealObject', 'StringObject', 'EnumObject', 'ArrayObject'
    ])

@dataclass
class TypeConfig:
    """Configuration for type mappings and generation through cocotb APIs."""
    import_statements: List[str] = field(default_factory=lambda: [
        'from __future__ import annotations',
        'import cocotb.handle',
        'import cocotb.types',
        'from typing_extensions import overload, Literal'
    ])
    
    base_classes: Dict[str, str] = field(default_factory=lambda: {
        'hierarchy': 'cocotb.handle.HierarchyObject',
        'hierarchy_array': 'cocotb.handle.HierarchyArrayObject',
        'array': 'cocotb.handle.ArrayObject',
        'logic': 'cocotb.handle.LogicObject',
        'logic_array': 'cocotb.handle.LogicArrayObject',
        'integer': 'cocotb.handle.IntegerObject',
        'real': 'cocotb.handle.RealObject',
        'enum': 'cocotb.handle.EnumObject',
        'string': 'cocotb.handle.StringObject'
    })
    
    value_types: Dict[str, str] = field(default_factory=lambda: {
        'logic': 'cocotb.types.Logic',
        'logic_array': 'cocotb.types.LogicArray',
        'integer': 'int',
        'real': 'float',
        'string': 'bytes',
        'enum': 'str'
    })
    
    value_annotations: Dict[str, str] = field(default_factory=lambda: {
        'LogicObject': 'cocotb.types.Logic',
        'LogicArrayObject': 'cocotb.types.LogicArray', 
        'IntegerObject': 'int',
        'RealObject': 'float',
        'StringObject': 'bytes',
        'EnumObject': 'str'
    })
    
    fallback_types: Dict[str, str] = field(default_factory=lambda: {
        'value': 'Any',
        'handle': 'cocotb.handle.ValueObjectBase[Any, Any]',
        'base': 'cocotb.handle.SimHandleBase'
    })
    
    patterns: TypePatterns = field(default_factory=TypePatterns)

@dataclass
class DiscoveryConfig:
    """Configuration for hierarchy discovery through cocotb handles."""
    max_depth: int = 100
    scope_types: Set[str] = field(default_factory=lambda: {
        'MODULE', 'STRUCTURE', 'GENARRAY', 'PACKAGE', 
        'BLOCK', 'FUNCTION', 'TASK', 'PROCESS', 'GENERATE'
    })
    array_types: Set[str] = field(default_factory=lambda: {'NETARRAY', 'LOGIC_ARRAY'})
    generate_prefixes: List[str] = field(default_factory=lambda: ['gen_', 'generate_', 'for_', 'if_'])

@dataclass
class OutputConfig:
    """Configuration for stub file output."""
    default_stub_dir: str = '.'
    stub_filename: str = 'copra_stubs.pyi'
    root_class_name: str = 'DUT'
    env_var_stub_dir: str = 'COPRA_STUB_DIR'
    header_lines: List[str] = field(default_factory=lambda: [
        'This file was automatically generated by copra',
        'It provides type stubs for your HDL design for use with cocotb'
    ])

@dataclass
class CopraConfig:
    """Main configuration for copra - type stub generation through cocotb APIs only."""
    types: TypeConfig = field(default_factory=TypeConfig)
    discovery: DiscoveryConfig = field(default_factory=DiscoveryConfig)
    output: OutputConfig = field(default_factory=OutputConfig)
    
    @classmethod
    def from_env(cls) -> 'CopraConfig':
        """Load configuration from environment variables."""
        config = cls()
        
        if stub_dir := os.getenv('COPRA_STUB_DIR'):
            config.output.default_stub_dir = stub_dir
        
        if max_depth := os.getenv('COPRA_MAX_DEPTH'):
            try:
                config.discovery.max_depth = int(max_depth)
            except ValueError:
                pass
                
        return config

def get_config() -> CopraConfig:
    """Get the global configuration instance."""
    return CopraConfig.from_env() 
