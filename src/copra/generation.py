# Copyright cocotb contributors
# Licensed under the Revised BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-3-Clause

"""Code generation utilities for copra.

This module provides tools for generating testbench templates, documentation,
and other code artifacts based on DUT analysis.
"""

from pathlib import Path
from typing import Dict, List

from cocotb.handle import HierarchyObject

from .core import discover_hierarchy
from .utils import to_capwords


def generate_testbench_template(dut: HierarchyObject, output_file: str = "test_template.py") -> str:
    """Generate a testbench template with proper typing based on the DUT.
    
    Creates a complete testbench template file with proper type annotations,
    common test patterns, and placeholder code for typical verification scenarios.
    
    Args:
    ----
        dut: The DUT object to generate template for.
        output_file: Path to write the template to.
        
    Returns:
    -------
        Generated template content as a string.
        
    Example:
    -------
        template = generate_testbench_template(dut, "test_cpu.py")
        # Creates a complete testbench file with proper typing
    """
    hierarchy = discover_hierarchy(dut)
    
    # Extract signal names for the template
    signals = []
    clock_signals = []
    reset_signals = []
    
    dut_name = getattr(dut, '_name', 'dut')
    
    for path, obj_type in hierarchy.items():
        # Extract signal names, handling both top-level and nested paths
        if path.startswith(f"{dut_name}."):
            signal_name = path[len(f"{dut_name}."):]
            # Only consider direct children (no further nesting)
            if '.' not in signal_name:
                signals.append(signal_name)
                # Detect common signal patterns
                if 'clk' in signal_name.lower() or 'clock' in signal_name.lower():
                    clock_signals.append(signal_name)
                elif 'rst' in signal_name.lower() or 'reset' in signal_name.lower():
                    reset_signals.append(signal_name)
        elif '.' not in path and path != dut_name:  # Top-level signals without DUT prefix, excluding DUT itself
            signals.append(path)
            # Detect common signal patterns
            if 'clk' in path.lower() or 'clock' in path.lower():
                clock_signals.append(path)
            elif 'rst' in path.lower() or 'reset' in path.lower():
                reset_signals.append(path)
    
    # Choose default clock and reset
    default_clock = clock_signals[0] if clock_signals else "clk"
    default_reset = reset_signals[0] if reset_signals else "rst_n"
    
    template = f'''"""Testbench for {dut._name} module.

This testbench was auto-generated by copra and provides a starting point
for comprehensive verification of the {dut._name} module.
"""

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, FallingEdge, Timer, ClockCycles
from cocotb.types import LogicArray
from cocotb.regression import TestFactory

# Import the generated stub for type hints
from dut import DutType


class {to_capwords(dut._name)}TestBench:
    """Test bench class for {dut._name} module."""
    
    def __init__(self, dut: DutType):
        """Initialize the testbench.
        
        Args:
        ----
            dut: The device under test with proper typing.
        """
        self.dut = dut
        self.clock_period = 10  # ns
        
    async def setup_clock(self):
        """Set up the clock signal."""
        clock = Clock(self.dut.{default_clock}, self.clock_period, units="ns")
        cocotb.start_soon(clock.start())
        
    async def reset_dut(self):
        """Perform a reset sequence."""
        self.dut.{default_reset}.value = 0
        await ClockCycles(self.dut.{default_clock}, 5)
        self.dut.{default_reset}.value = 1
        await ClockCycles(self.dut.{default_clock}, 2)
        
    async def wait_clock_cycles(self, cycles: int = 1):
        """Wait for specified number of clock cycles."""
        await ClockCycles(self.dut.{default_clock}, cycles)


@cocotb.test()
async def test_{dut._name.lower()}_reset(dut: DutType):
    """Test reset functionality.
    
    Verifies that the module properly responds to reset signals
    and initializes to a known state.
    """
    tb = {to_capwords(dut._name)}TestBench(dut)
    await tb.setup_clock()
    
    # Test reset assertion
    dut.{default_reset}.value = 0
    await tb.wait_clock_cycles(10)
    
    # TODO: Add assertions for reset state
    # Example: assert dut.output_signal.value == 0
    
    # Test reset deassertion
    await tb.reset_dut()
    
    # TODO: Add assertions for post-reset state
    # Example: assert dut.ready.value == 1
    
    cocotb.log.info("Reset test completed successfully")


@cocotb.test()
async def test_{dut._name.lower()}_basic_operation(dut: DutType):
    """Test basic module operation.
    
    Performs fundamental functional testing of the module's
    primary operation modes.
    """
    tb = {to_capwords(dut._name)}TestBench(dut)
    await tb.setup_clock()
    await tb.reset_dut()
    
    # Basic operation test sequence
    for i in range(20):
        # TODO: Set input values based on your module's interface
        # Example:
        # dut.data_in.value = i
        # dut.valid_in.value = 1
        
        await tb.wait_clock_cycles(1)
        
        # TODO: Check outputs and verify expected behavior
        # Example:
        # if dut.valid_out.value:
        #     assert dut.data_out.value == expected_value
        
    cocotb.log.info("Basic operation test completed successfully")


@cocotb.test()
async def test_{dut._name.lower()}_edge_cases(dut: DutType):
    """Test edge cases and boundary conditions.
    
    Verifies module behavior under edge cases, boundary conditions,
    and potential error scenarios.
    """
    tb = {to_capwords(dut._name)}TestBench(dut)
    await tb.setup_clock()
    await tb.reset_dut()
    
    # TODO: Implement edge case testing
    # Examples:
    # - Maximum/minimum input values
    # - Rapid input changes
    # - Invalid input combinations
    # - Buffer overflow/underflow conditions
    
    cocotb.log.info("Edge case test completed successfully")


async def run_random_test(dut: DutType, num_transactions: int = 100):
    """Run randomized testing.
    
    Args:
    ----
        dut: Device under test.
        num_transactions: Number of random transactions to perform.
    """
    import random
    
    tb = {to_capwords(dut._name)}TestBench(dut)
    await tb.setup_clock()
    await tb.reset_dut()
    
    for _ in range(num_transactions):
        # TODO: Generate random inputs
        # Example:
        # random_data = random.randint(0, 2**32-1)
        # dut.data_in.value = random_data
        
        await tb.wait_clock_cycles(random.randint(1, 5))
        
        # TODO: Verify outputs
        
    cocotb.log.info(f"Random test with {{num_transactions}} transactions completed")


# Create test factory for parameterized testing
factory = TestFactory(run_random_test)
factory.add_option("num_transactions", [50, 100, 200])
factory.generate_tests()


# Available signals in the DUT:
{chr(10).join(f"# - dut.{signal}" for signal in sorted(signals))}

# Clock signals detected: {', '.join(clock_signals) if clock_signals else 'None detected'}
# Reset signals detected: {', '.join(reset_signals) if reset_signals else 'None detected'}

# TODO: Customize this testbench for your specific module:
# 1. Update signal assignments based on your module's interface
# 2. Add specific test scenarios for your module's functionality  
# 3. Implement proper assertions and checking logic
# 4. Add coverage collection if needed
# 5. Consider adding constrained random testing
'''
    
    # Write template to file
    template_path = Path(output_file)
    template_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(template_path, 'w', encoding='utf-8') as f:
        f.write(template)
    
    print(f"[copra] Generated testbench template: {template_path}")
    return template


def generate_interface_documentation(dut: HierarchyObject, output_file: str = "interface.dutdoc.md") -> str:
    """Generate markdown documentation for the DUT interface.
    
    Args:
    ----
        dut: The DUT object to document.
        output_file: Path to write the documentation to.
        
    Returns:
    -------
        Generated documentation content as a string.
    """
    hierarchy = discover_hierarchy(dut)
    
    # Organize signals by type and hierarchy
    signals_by_type = {}
    for path, obj_type in hierarchy.items():
        type_name = obj_type.__name__
        if type_name not in signals_by_type:
            signals_by_type[type_name] = []
        signals_by_type[type_name].append(path)
    
    doc_content = f"""# {dut._name} Interface Documentation

Auto-generated interface documentation for the {dut._name} module.

## Overview

This document describes the complete interface of the {dut._name} module, including all signals, their types, and hierarchical organization.

## Signal Summary

| Signal Type | Count |
|-------------|-------|
"""
    
    for signal_type, signals in signals_by_type.items():
        doc_content += f"| {signal_type} | {len(signals)} |\n"
    
    doc_content += f"\n**Total Signals:** {len(hierarchy)}\n\n"
    
    # Document each signal type
    for signal_type, signals in sorted(signals_by_type.items()):
        doc_content += f"## {signal_type} Signals\n\n"
        
        for signal in sorted(signals):
            # Determine signal direction and purpose based on naming conventions
            direction = "Unknown"
            if any(pattern in signal.lower() for pattern in ['in', 'input']):
                direction = "Input"
            elif any(pattern in signal.lower() for pattern in ['out', 'output']):
                direction = "Output"
            elif any(pattern in signal.lower() for pattern in ['clk', 'clock']):
                direction = "Clock"
            elif any(pattern in signal.lower() for pattern in ['rst', 'reset']):
                direction = "Reset"
            
            doc_content += f"### `{signal}`\n\n"
            doc_content += f"- **Type:** {signal_type}\n"
            doc_content += f"- **Direction:** {direction}\n"
            doc_content += f"- **Hierarchy Level:** {signal.count('.') + 1}\n\n"
    
    # Write documentation to file
    doc_path = Path(output_file)
    doc_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(doc_path, 'w', encoding='utf-8') as f:
        f.write(doc_content)
    
    print(f"[copra] Generated interface documentation: {doc_path}")
    return doc_content 