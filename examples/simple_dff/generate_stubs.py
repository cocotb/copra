#!/usr/bin/env python3
"""Generate type stubs for the simple DFF example DUT.

This script demonstrates how to use copra to generate type stubs
for a D flip-flop by running an actual cocotb simulation.
"""

import sys
from pathlib import Path

# Add copra to the path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

from copra import (
    create_stub_from_dut,
    discover_hierarchy,
    generate_stub,
    run_discovery_simulation,
)


def generate_dff_stubs():
    """Generate type stubs for the DFF example DUT using real simulation."""
    print("=" * 60)
    print("Simple DFF Example: End-to-End Stub Generation")
    print("=" * 60)

    # Define source files
    base_dir = Path(__file__).parent
    verilog_sources = [str(base_dir / "dff.sv")]
    
    print("Source files:")
    for src in verilog_sources:
        print(f"  - {src}")
    
    print("\nTop module: dff")
    print("Target simulator: icarus")

    try:
        print("\n" + "=" * 40)
        print("Step 1: Running DUT Discovery Simulation")
        print("=" * 40)

        # Run discovery simulation to get the real DUT
        dut = run_discovery_simulation(
            top_module="dff",
            verilog_sources=verilog_sources,
            simulator="icarus",
            cleanup=True
        )

        print(f"✓ Successfully discovered DUT: {dut._name}")

        print("\n" + "=" * 40)
        print("Step 2: Discovering DUT Hierarchy")
        print("=" * 40)

        # Discover the hierarchy from the real DUT
        hierarchy = discover_hierarchy(dut)
        
        print(f"✓ Discovered {len(hierarchy)} signals/modules in hierarchy")
        
        # Print hierarchy information
        print("\nHierarchy overview:")
        for path, obj_type in sorted(hierarchy.items()):
            # Safe way to get type name
            if hasattr(obj_type, '__name__'):
                type_name = obj_type.__name__
            elif hasattr(obj_type, '__class__'):
                type_name = obj_type.__class__.__name__
            else:
                type_name = str(type(obj_type).__name__)
            print(f"  {path}: {type_name}")

        print("\n" + "=" * 40)
        print("Step 3: Generating Type Stubs")
        print("=" * 40)

        # Generate stub content using the real hierarchy
        stub_content = generate_stub(hierarchy)

        # Write to the dut.pyi file in this directory
        stub_file = base_dir / "dut.pyi"
        with open(stub_file, "w") as f:
            f.write(stub_content)

        print(f"✓ Generated stub file: {stub_file}")
        print(f"  Stub size: {len(stub_content)} characters")
        print(f"  Lines: {len(stub_content.splitlines())}")

        print("\n" + "=" * 40)
        print("Step 4: Validating Generated Stubs")
        print("=" * 40)

        # Show a preview of the generated content
        lines = stub_content.splitlines()
        print("Generated stub preview (first 20 lines):")
        print("-" * 50)
        for i, line in enumerate(lines[:20], 1):
            print(f"{i:2d}: {line}")
        if len(lines) > 20:
            print(f"... and {len(lines) - 20} more lines")
        print("-" * 50)

        print("\n" + "=" * 40)
        print("Step 5: DFF-Specific Analysis")
        print("=" * 40)

        # Analyze the DFF-specific signals
        expected_signals = ['clk', 'rst_n', 'd', 'q']
        found_signals = []
        
        for path in hierarchy.keys():
            signal_name = path.split('.')[-1]  # Get the last part of the path
            if signal_name in expected_signals:
                found_signals.append(signal_name)
        
        print("DFF Signal Analysis:")
        for signal in expected_signals:
            status = "✓ Found" if signal in found_signals else "✗ Missing"
            print(f"  {signal}: {status}")
        
        if len(found_signals) == len(expected_signals):
            print("✓ All expected DFF signals discovered!")
        else:
            print(f"⚠ Found {len(found_signals)}/{len(expected_signals)} expected signals")

        print("\n" + "=" * 40)
        print("Generation Complete!")
        print("=" * 40)
        
        print("✓ Successfully generated end-to-end type stubs for DFF")
        print("✓ Stubs are based on real DUT hierarchy from simulation")
        print("✓ Ready for use in IDE with autocompletion and type checking")
        print("✓ DFF-specific signals properly discovered and typed")
        
        return stub_content

    except Exception as e:
        print(f"✗ Error during stub generation: {e}")
        print("\nFallback: Generating basic DFF stubs without simulation")
        
        # Fallback to basic stub generation for DFF
        basic_stub = """# Basic type stub for DFF example
# Generated by copra (fallback mode)

from cocotb.handle import HierarchyObject, SimHandleBase

class Dff(HierarchyObject):
    \"\"\"Simple D Flip-Flop DUT.
    
    A basic D flip-flop with clock and active-low reset.
    
    Signals:
        clk: Clock input
        rst_n: Active-low reset
        d: Data input
        q: Data output (registered)
    \"\"\"
    
    clk: SimHandleBase
    rst_n: SimHandleBase
    d: SimHandleBase
    q: SimHandleBase

# Type alias for the main DUT
DutType = Dff
"""
        
        stub_file = base_dir / "dut.pyi"
        with open(stub_file, "w") as f:
            f.write(basic_stub)
        
        print(f"✓ Generated basic DFF stub file: {stub_file}")
        return basic_stub


if __name__ == "__main__":
    generate_dff_stubs()
