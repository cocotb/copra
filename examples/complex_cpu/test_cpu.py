"""Comprehensive test for the complex CPU design.

This test demonstrates copra's capabilities with a large, complex design
featuring multiple cores, buses, and hierarchical modules.
"""

from typing import Any, cast

import cocotb
from cocotb.clock import Clock
from cocotb.regression import TestFactory
from cocotb.triggers import ClockCycles, RisingEdge

# Import the generated DUT type (will be generated by copra)
try:
    from cpu_top import CpuTopType

    DUT_TYPE_AVAILABLE = True
except ImportError:
    # Fallback if stub not generated yet
    DUT_TYPE_AVAILABLE = False
    CpuTopType = Any


class ComplexCpuTestBench:
    """Comprehensive testbench for the complex CPU design."""

    def __init__(self, dut: Any):
        """Initialize testbench.

        Args:
        ----
            dut: The DUT instance from cocotb.

        """
        if DUT_TYPE_AVAILABLE:
            self.dut = cast(CpuTopType, dut)
        else:
            self.dut = dut

        self.clock_period = 10  # ns
        self.apb_clock_period = 20  # ns (slower APB clock)

    async def setup_clocks(self):
        """Set up clock generation for all clock domains."""
        # Main system clock
        main_clock = Clock(self.dut.clk, self.clock_period, units="ns")
        cocotb.start_soon(main_clock.start())

        # APB clock (for CSR access)
        apb_clock = Clock(self.dut.s_apb_pclk, self.apb_clock_period, units="ns")
        cocotb.start_soon(apb_clock.start())

    async def reset_system(self):
        """Reset the entire system."""
        # Assert resets
        self.dut.rst_n.value = 0
        self.dut.s_apb_presetn.value = 0
        self.dut.test_mode.value = 0
        self.dut.global_enable.value = 0
        self.dut.core_enable.value = 0

        # Initialize AXI interfaces
        await self._init_axi_interfaces()

        # Initialize APB interface
        await self._init_apb_interface()

        # Initialize other interfaces
        await self._init_other_interfaces()

        # Wait for reset
        await ClockCycles(self.dut.clk, 10)

        # Deassert resets
        self.dut.rst_n.value = 1
        self.dut.s_apb_presetn.value = 1

        # Wait for reset deassertion
        await ClockCycles(self.dut.clk, 10)

        # Enable the system
        self.dut.global_enable.value = 1
        self.dut.core_enable.value = 0xF  # Enable all 4 cores

        # Wait for system ready
        await ClockCycles(self.dut.clk, 20)

    async def _init_axi_interfaces(self):
        """Initialize AXI interface signals."""
        # Instruction Fetch AXI (slave responses)
        self.dut.m_axi_if_awready.value = 1
        self.dut.m_axi_if_wready.value = 1
        self.dut.m_axi_if_bid.value = 0
        self.dut.m_axi_if_bresp.value = 0
        self.dut.m_axi_if_bvalid.value = 0
        self.dut.m_axi_if_arready.value = 1
        self.dut.m_axi_if_rid.value = 0
        self.dut.m_axi_if_rdata.value = 0x00000013  # NOP instruction
        self.dut.m_axi_if_rresp.value = 0
        self.dut.m_axi_if_rlast.value = 1
        self.dut.m_axi_if_rvalid.value = 0

        # Data Memory AXI (slave responses)
        self.dut.m_axi_dm_awready.value = 1
        self.dut.m_axi_dm_wready.value = 1
        self.dut.m_axi_dm_bid.value = 0
        self.dut.m_axi_dm_bresp.value = 0
        self.dut.m_axi_dm_bvalid.value = 0
        self.dut.m_axi_dm_arready.value = 1
        self.dut.m_axi_dm_rid.value = 0
        self.dut.m_axi_dm_rdata.value = 0
        self.dut.m_axi_dm_rresp.value = 0
        self.dut.m_axi_dm_rlast.value = 1
        self.dut.m_axi_dm_rvalid.value = 0

    async def _init_apb_interface(self):
        """Initialize APB interface signals."""
        self.dut.s_apb_paddr.value = 0
        self.dut.s_apb_psel.value = 0
        self.dut.s_apb_penable.value = 0
        self.dut.s_apb_pwrite.value = 0
        self.dut.s_apb_pwdata.value = 0
        self.dut.s_apb_pstrb.value = 0

    async def _init_other_interfaces(self):
        """Initialize other interface signals."""
        # Interrupts
        self.dut.interrupts.value = 0

        # Debug interface
        self.dut.debug_req.value = 0
        self.dut.debug_addr.value = 0
        self.dut.debug_wdata.value = 0
        self.dut.debug_we.value = 0

    async def simulate_axi_memory_responses(self):
        """Simulate memory responses on AXI interfaces."""
        while True:
            # Instruction fetch responses
            if self.dut.m_axi_if_arvalid.value and self.dut.m_axi_if_arready.value:
                await ClockCycles(self.dut.clk, 2)  # Memory latency
                self.dut.m_axi_if_rvalid.value = 1
                await ClockCycles(self.dut.clk, 1)
                if self.dut.m_axi_if_rready.value:
                    self.dut.m_axi_if_rvalid.value = 0

            # Data memory responses
            if self.dut.m_axi_dm_arvalid.value and self.dut.m_axi_dm_arready.value:
                await ClockCycles(self.dut.clk, 3)  # Memory latency
                self.dut.m_axi_dm_rvalid.value = 1
                await ClockCycles(self.dut.clk, 1)
                if self.dut.m_axi_dm_rready.value:
                    self.dut.m_axi_dm_rvalid.value = 0

            # Write responses
            if self.dut.m_axi_dm_awvalid.value and self.dut.m_axi_dm_wvalid.value:
                await ClockCycles(self.dut.clk, 2)
                self.dut.m_axi_dm_bvalid.value = 1
                await ClockCycles(self.dut.clk, 1)
                if self.dut.m_axi_dm_bready.value:
                    self.dut.m_axi_dm_bvalid.value = 0

            await ClockCycles(self.dut.clk, 1)

    async def read_csr(self, addr: int) -> int:
        """Read from a CSR register via APB."""
        # Setup read transaction
        self.dut.s_apb_paddr.value = addr
        self.dut.s_apb_psel.value = 1
        self.dut.s_apb_penable.value = 0
        self.dut.s_apb_pwrite.value = 0

        await RisingEdge(self.dut.s_apb_pclk)

        # Enable phase
        self.dut.s_apb_penable.value = 1

        await RisingEdge(self.dut.s_apb_pclk)

        # Wait for ready
        while not self.dut.s_apb_pready.value:
            await RisingEdge(self.dut.s_apb_pclk)

        # Read data
        data = self.dut.s_apb_prdata.value

        # End transaction
        self.dut.s_apb_psel.value = 0
        self.dut.s_apb_penable.value = 0

        return int(data)

    async def write_csr(self, addr: int, data: int):
        """Write to a CSR register via APB."""
        # Setup write transaction
        self.dut.s_apb_paddr.value = addr
        self.dut.s_apb_psel.value = 1
        self.dut.s_apb_penable.value = 0
        self.dut.s_apb_pwrite.value = 1
        self.dut.s_apb_pwdata.value = data
        self.dut.s_apb_pstrb.value = 0xF

        await RisingEdge(self.dut.s_apb_pclk)

        # Enable phase
        self.dut.s_apb_penable.value = 1

        await RisingEdge(self.dut.s_apb_pclk)

        # Wait for ready
        while not self.dut.s_apb_pready.value:
            await RisingEdge(self.dut.s_apb_pclk)

        # End transaction
        self.dut.s_apb_psel.value = 0
        self.dut.s_apb_penable.value = 0
        self.dut.s_apb_pwrite.value = 0

    async def inject_interrupts(self, interrupt_mask: int):
        """Inject interrupts into the system."""
        self.dut.interrupts.value = interrupt_mask
        await ClockCycles(self.dut.clk, 5)
        self.dut.interrupts.value = 0

    async def debug_register_access(self, core_id: int, reg_addr: int, data: int = None):
        """Access CPU registers via debug interface."""
        self.dut.debug_req.value = 1
        self.dut.debug_addr.value = (core_id << 8) | reg_addr

        if data is not None:
            # Write operation
            self.dut.debug_we.value = 1
            self.dut.debug_wdata.value = data
        else:
            # Read operation
            self.dut.debug_we.value = 0

        await ClockCycles(self.dut.clk, 1)

        # Wait for acknowledge
        while not self.dut.debug_ack.value:
            await ClockCycles(self.dut.clk, 1)

        if data is None:
            # Return read data
            result = int(self.dut.debug_rdata.value)
        else:
            result = None

        # End debug transaction
        self.dut.debug_req.value = 0
        self.dut.debug_we.value = 0

        return result


@cocotb.test()
async def test_cpu_reset_and_initialization(dut):
    """Test CPU reset and initialization sequence."""
    tb = ComplexCpuTestBench(dut)

    # Start memory simulation
    cocotb.start_soon(tb.simulate_axi_memory_responses())

    await tb.setup_clocks()
    await tb.reset_system()

    # Verify system is ready
    assert dut.system_ready.value == 1, "System should be ready after reset"

    # Check that all cores are active
    core_status = int(dut.core_active.value)
    assert core_status == 0xF, f"All cores should be active, got {core_status:04b}"

    dut._log.info("Reset and initialization test completed successfully")


@cocotb.test()
async def test_csr_access(dut):
    """Test Control and Status Register access via APB."""
    tb = ComplexCpuTestBench(dut)

    cocotb.start_soon(tb.simulate_axi_memory_responses())
    await tb.setup_clocks()
    await tb.reset_system()

    # Read core status register
    core_status = await tb.read_csr(0x0000)
    dut._log.info(f"Core status: 0x{core_status:08x}")

    # Read performance counters
    cycle_count = await tb.read_csr(0x0010)
    instr_count = await tb.read_csr(0x0014)
    cache_hits = await tb.read_csr(0x0018)
    cache_misses = await tb.read_csr(0x001C)

    dut._log.info("Performance counters:")
    dut._log.info(f"  Cycles: {cycle_count}")
    dut._log.info(f"  Instructions: {instr_count}")
    dut._log.info(f"  Cache hits: {cache_hits}")
    dut._log.info(f"  Cache misses: {cache_misses}")

    # Let the system run for a while
    await ClockCycles(dut.clk, 1000)

    # Read counters again to verify they're incrementing
    new_cycle_count = await tb.read_csr(0x0010)
    assert new_cycle_count > cycle_count, "Cycle counter should increment"

    dut._log.info("CSR access test completed successfully")


@cocotb.test()
async def test_interrupt_handling(dut):
    """Test interrupt handling across multiple cores."""
    tb = ComplexCpuTestBench(dut)

    cocotb.start_soon(tb.simulate_axi_memory_responses())
    await tb.setup_clocks()
    await tb.reset_system()

    # Let the system run for a bit
    await ClockCycles(dut.clk, 100)

    # Inject various interrupts
    interrupt_patterns = [0x0001, 0x0003, 0x00FF, 0x5555, 0xAAAA]

    for pattern in interrupt_patterns:
        dut._log.info(f"Injecting interrupt pattern: 0x{pattern:04x}")
        await tb.inject_interrupts(pattern)

        # Check interrupt acknowledgment
        if dut.interrupt_ack.value:
            interrupt_id = int(dut.interrupt_id.value)
            dut._log.info(f"Interrupt acknowledged, ID: {interrupt_id}")

        await ClockCycles(dut.clk, 50)

    dut._log.info("Interrupt handling test completed successfully")


@cocotb.test()
async def test_debug_interface(dut):
    """Test debug interface for register access."""
    tb = ComplexCpuTestBench(dut)

    cocotb.start_soon(tb.simulate_axi_memory_responses())
    await tb.setup_clocks()
    await tb.reset_system()

    # Test debug access to different cores
    for core_id in range(4):
        dut._log.info(f"Testing debug access to core {core_id}")

        # Write to register 1
        await tb.debug_register_access(core_id, 1, 0xDEADBEEF)

        # Read back from register 1
        read_data = await tb.debug_register_access(core_id, 1)

        # Note: Register 0 is hardwired to 0 in RISC-V, so we can't test it
        # For other registers, the debug interface should work
        dut._log.info(f"Core {core_id} register 1: wrote 0xDEADBEEF, read 0x{read_data:08x}")

    dut._log.info("Debug interface test completed successfully")


@cocotb.test()
async def test_axi_traffic_patterns(dut):
    """Test various AXI traffic patterns."""
    tb = ComplexCpuTestBench(dut)

    cocotb.start_soon(tb.simulate_axi_memory_responses())
    await tb.setup_clocks()
    await tb.reset_system()

    # Monitor AXI traffic for a period
    start_time = cocotb.utils.get_sim_time()

    if_transactions = 0
    dm_transactions = 0

    # Run for a significant period to observe traffic
    for _ in range(2000):
        await ClockCycles(dut.clk, 1)

        # Count instruction fetch transactions
        if dut.m_axi_if_arvalid.value and dut.m_axi_if_arready.value:
            if_transactions += 1
            addr = int(dut.m_axi_if_araddr.value)
            dut._log.debug(f"IF transaction to address 0x{addr:08x}")

        # Count data memory transactions
        if dut.m_axi_dm_arvalid.value and dut.m_axi_dm_arready.value:
            dm_transactions += 1
            addr = int(dut.m_axi_dm_araddr.value)
            dut._log.debug(f"DM read transaction to address 0x{addr:08x}")

        if dut.m_axi_dm_awvalid.value and dut.m_axi_dm_awready.value:
            dm_transactions += 1
            addr = int(dut.m_axi_dm_awaddr.value)
            dut._log.debug(f"DM write transaction to address 0x{addr:08x}")

    end_time = cocotb.utils.get_sim_time()
    duration = end_time - start_time

    dut._log.info(f"AXI traffic analysis over {duration}:")
    dut._log.info(f"  Instruction fetch transactions: {if_transactions}")
    dut._log.info(f"  Data memory transactions: {dm_transactions}")
    dut._log.info(f"  Total AXI transactions: {if_transactions + dm_transactions}")

    # Verify we saw some activity
    assert if_transactions > 0, "Should see instruction fetch activity"

    dut._log.info("AXI traffic patterns test completed successfully")


async def run_stress_test(dut, duration_cycles: int = 5000):
    """Run a stress test with all features active."""
    tb = ComplexCpuTestBench(dut)

    cocotb.start_soon(tb.simulate_axi_memory_responses())
    await tb.setup_clocks()
    await tb.reset_system()

    # Start periodic interrupt injection
    async def interrupt_injector():
        for i in range(duration_cycles // 100):
            await ClockCycles(dut.clk, 100)
            await tb.inject_interrupts(0x0001 << (i % 16))

    cocotb.start_soon(interrupt_injector())

    # Start periodic debug access
    async def debug_accessor():
        for i in range(duration_cycles // 200):
            await ClockCycles(dut.clk, 200)
            core_id = i % 4
            reg_addr = (i % 31) + 1  # Skip register 0
            await tb.debug_register_access(core_id, reg_addr, i * 0x1000 + reg_addr)

    cocotb.start_soon(debug_accessor())

    # Start periodic CSR access
    async def csr_accessor():
        csr_addrs = [0x0000, 0x0010, 0x0014, 0x0018, 0x001C, 0x0020, 0x0024]
        for i in range(duration_cycles // 150):
            await ClockCycles(dut.clk, 150)
            addr = csr_addrs[i % len(csr_addrs)]
            value = await tb.read_csr(addr)
            dut._log.debug(f"CSR 0x{addr:04x} = 0x{value:08x}")

    cocotb.start_soon(csr_accessor())

    # Run the main simulation
    await ClockCycles(dut.clk, duration_cycles)

    # Read final performance counters
    final_cycles = await tb.read_csr(0x0010)
    final_instrs = await tb.read_csr(0x0014)
    final_cache_hits = await tb.read_csr(0x0018)
    final_cache_misses = await tb.read_csr(0x001C)

    dut._log.info(f"Stress test completed after {duration_cycles} cycles:")
    dut._log.info(f"  Performance cycles: {final_cycles}")
    dut._log.info(f"  Instructions: {final_instrs}")
    dut._log.info(f"  Cache hits: {final_cache_hits}")
    dut._log.info(f"  Cache misses: {final_cache_misses}")

    if final_instrs > 0:
        ipc = final_instrs / final_cycles if final_cycles > 0 else 0
        dut._log.info(f"  Instructions per cycle: {ipc:.3f}")

    if final_cache_hits + final_cache_misses > 0:
        hit_rate = final_cache_hits / (final_cache_hits + final_cache_misses)
        dut._log.info(f"  Cache hit rate: {hit_rate:.3f}")


# TestFactory for parameterized stress tests
factory = TestFactory(run_stress_test)
factory.add_option("duration_cycles", [1000, 3000, 5000])
factory.generate_tests()
