# Copyright cocotb contributors
# Licensed under the Revised BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-3-Clause

"""Test stable ordering in generated stubs."""

import tempfile
from pathlib import Path

def test_stub_ordering_is_deterministic():
    """Test that generated stubs have deterministic ordering across multiple runs."""
    
    from copra.discovery import HierarchyDict, HDLNode
    from copra.generation import generate_stub
    
    hierarchy = HierarchyDict()
    
    test_signals = [
        ("z_signal", "cocotb.handle.LogicObject", False),
        ("a_signal", "cocotb.handle.LogicArrayObject", False), 
        ("m_signal", "cocotb.handle.LogicObject", False),
        ("b_bus", "cocotb.handle.HierarchyObject", True),
    ]
    
    for signal_name, py_type, is_scope in test_signals:
        node = HDLNode(
            path=f"dut.{signal_name}",
            py_type=py_type,
            width=8 if "Array" in py_type else 1,
            is_scope=is_scope
        )
        hierarchy._nodes[f"dut.{signal_name}"] = node  # type: ignore[reportPrivateUsage]
        hierarchy._build_tree_node(node)  # type: ignore[reportPrivateUsage]
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)

        stub_path1 = generate_stub(hierarchy, temp_path / "run1")
        content1 = stub_path1.read_text()
        
        stub_path2 = generate_stub(hierarchy, temp_path / "run2")
        content2 = stub_path2.read_text()
        
        stub_path3 = generate_stub(hierarchy, temp_path / "run3")
        content3 = stub_path3.read_text()
        
        assert content1 == content2 == content3, "Generated stubs should be deterministic across multiple runs"
        
        expected_content = """from __future__ import annotations
import cocotb.handle
import cocotb.types

# This file was automatically generated by copra
# It provides type stubs for your HDL design for use with cocotb

class DUT(cocotb.handle.HierarchyObject):
    a_signal: cocotb.handle.LogicArrayObject
    b_bus: BBus
    m_signal: cocotb.handle.LogicObject
    z_signal: cocotb.handle.LogicObject
"""
        
        assert content1 == expected_content, "Generated stub content should match expected golden reference"


def test_many_signals_have_stable_ordering():
    """Test that many signals maintain alphabetical order."""
    
    from copra.discovery import HierarchyDict, HDLNode
    from copra.generation import generate_stub
    
    hierarchy = HierarchyDict()
    
    # Create signals in random order to test sorting
    signals = ["zebra", "alpha", "beta", "gamma", "delta", "omega", "sigma"] 
    for signal in signals:
        node = HDLNode(
            path=f"dut.{signal}",
            py_type="cocotb.handle.LogicObject", 
            width=1,
            is_scope=False
        )
        hierarchy._nodes[f"dut.{signal}"] = node  # type: ignore[reportPrivateUsage]
        hierarchy._build_tree_node(node)  # type: ignore[reportPrivateUsage]
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        stub_path = generate_stub(hierarchy, temp_path)
        content = stub_path.read_text()
        
        # Verify the content matches expected alphabetical ordering
        expected_content = """from __future__ import annotations
import cocotb.handle
import cocotb.types

# This file was automatically generated by copra
# It provides type stubs for your HDL design for use with cocotb

class DUT(cocotb.handle.HierarchyObject):
    alpha: cocotb.handle.LogicObject
    beta: cocotb.handle.LogicObject
    delta: cocotb.handle.LogicObject
    gamma: cocotb.handle.LogicObject
    omega: cocotb.handle.LogicObject
    sigma: cocotb.handle.LogicObject
    zebra: cocotb.handle.LogicObject
"""
        
        assert content == expected_content, "Generated stub should have signals in alphabetical order"
